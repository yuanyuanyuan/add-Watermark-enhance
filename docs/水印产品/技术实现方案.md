# æ°´å°äº§å“æŠ€æœ¯å®ç°æ–¹æ¡ˆ

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„æ¦‚è§ˆ

### å‰ç«¯æŠ€æœ¯æ ˆ
- **æ¡†æ¶**: React 18 + TypeScript 5.0
- **æ ·å¼**: TailwindCSS + CSS Modules
- **çŠ¶æ€ç®¡ç†**: Zustand (è½»é‡çº§)
- **æ„å»ºå·¥å…·**: Vite 5.0
- **æµ‹è¯•**: Jest + React Testing Library

### æ ¸å¿ƒæŠ€æœ¯æ–¹æ¡ˆ

#### 1. Canvasæ¸²æŸ“å¼•æ“æ¶æ„
```typescript
interface WatermarkEngine {
  // æ–‡å­—æ°´å°é…ç½®
  textWatermark: {
    content: string;
    fontSize: number;
    color: string;
    opacity: number;
    position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center';
    rotation: number;
  };
  
  // å›¾ç‰‡æ°´å°é…ç½®
  imageWatermark: {
    src: string;
    scale: number;
    opacity: number;
    position: { x: number; y: number };
    rotation: number;
  };
}
```

#### 2. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
**åˆ†å±‚æ¸²æŸ“æ¶æ„**:
- **L1**: ç¦»å±Canvasé¢„å¤„ç†
- **L2**: WebWorkerå¹¶è¡Œå¤„ç†
- **L3**: åˆ†å—å¤„ç†å¤§æ–‡ä»¶
- **L4**: æ¸è¿›å¼åŠ è½½

**å†…å­˜ç®¡ç†**:
```typescript
class MemoryManager {
  private maxMemoryMB = 100;
  private activeCanvases = new Set<HTMLCanvasElement>();
  
  allocateCanvas(width: number, height: number): HTMLCanvasElement {
    const estimatedMemory = (width * height * 4) / (1024 * 1024);
    if (this.getUsedMemory() + estimatedMemory > this.maxMemoryMB) {
      this.cleanupOldestCanvas();
    }
    return this.createCanvas(width, height);
  }
}
```

## ğŸ”§ æ ¸å¿ƒæ¨¡å—å®ç°

### æ¨¡å—1: æ–‡ä»¶å¤„ç†ç³»ç»Ÿ
```typescript
// æ–‡ä»¶è¯»å–ä¸éªŒè¯
class FileProcessor {
  private supportedFormats = ['image/jpeg', 'image/png'];
  private maxFileSize = 10 * 1024 * 1024; // 10MB

  async processFile(file: File): Promise<ProcessedImage> {
    // 1. æ ¼å¼éªŒè¯
    if (!this.supportedFormats.includes(file.type)) {
      throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼');
    }
    
    // 2. å¤§å°æ£€æŸ¥
    if (file.size > this.maxFileSize) {
      throw new Error('æ–‡ä»¶è¿‡å¤§ï¼Œæœ€å¤§æ”¯æŒ10MB');
    }
    
    // 3. å›¾ç‰‡é¢„åŠ è½½å’Œå…ƒæ•°æ®æå–
    const image = await this.loadImage(file);
    return {
      originalFile: file,
      image,
      dimensions: { width: image.width, height: image.height },
      metadata: await this.extractMetadata(file)
    };
  }
}
```

### æ¨¡å—2: æ°´å°æ¸²æŸ“å¼•æ“
```typescript
class WatermarkRenderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d')!;
  }

  async renderWatermark(
    image: HTMLImageElement,
    textConfig?: TextWatermarkConfig,
    imageConfig?: ImageWatermarkConfig
  ): Promise<Blob> {
    // 1. è®¾ç½®Canvaså°ºå¯¸
    this.canvas.width = image.width;
    this.canvas.height = image.height;
    
    // 2. ç»˜åˆ¶åŸå§‹å›¾ç‰‡
    this.ctx.drawImage(image, 0, 0);
    
    // 3. åº”ç”¨æ–‡å­—æ°´å°
    if (textConfig) {
      await this.applyTextWatermark(textConfig);
    }
    
    // 4. åº”ç”¨å›¾ç‰‡æ°´å°
    if (imageConfig) {
      await this.applyImageWatermark(imageConfig);
    }
    
    // 5. å¯¼å‡ºå¤„ç†åçš„å›¾ç‰‡
    return new Promise(resolve => {
      this.canvas.toBlob(resolve, 'image/jpeg', 0.92);
    });
  }

  private applyTextWatermark(config: TextWatermarkConfig) {
    this.ctx.save();
    
    // è®¾ç½®æ–‡å­—æ ·å¼
    this.ctx.font = `${config.fontSize}px Arial`;
    this.ctx.fillStyle = config.color;
    this.ctx.globalAlpha = config.opacity;
    
    // è®¡ç®—æ–‡å­—ä½ç½®
    const position = this.calculateTextPosition(config);
    
    // åº”ç”¨æ—‹è½¬
    this.ctx.translate(position.x, position.y);
    this.ctx.rotate(config.rotation * Math.PI / 180);
    
    // ç»˜åˆ¶æ–‡å­—
    this.ctx.fillText(config.content, 0, 0);
    
    this.ctx.restore();
  }
}
```

### æ¨¡å—3: SHA-256è¯ä¹¦ç³»ç»Ÿ
```typescript
class CertificateGenerator {
  private encoder = new TextEncoder();

  async generateCertificate(
    originalFile: File,
    watermarkParams: WatermarkParams,
    processedImage: Blob
  ): Promise<WatermarkCertificate> {
    
    // 1. è®¡ç®—åŸå§‹æ–‡ä»¶å“ˆå¸Œ
    const originalHash = await this.calculateFileHash(originalFile);
    
    // 2. è®¡ç®—å¤„ç†åå›¾ç‰‡å“ˆå¸Œ
    const processedHash = await this.calculateBlobHash(processedImage);
    
    // 3. ç”Ÿæˆè¯ä¹¦å…ƒæ•°æ®
    const metadata = {
      originalHash,
      processedHash,
      watermarkParams,
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    };
    
    // 4. è®¡ç®—è¯ä¹¦å“ˆå¸Œ
    const certificateHash = await this.calculateStringHash(
      JSON.stringify(metadata)
    );
    
    return {
      ...metadata,
      certificateHash
    };
  }

  private async calculateFileHash(file: File): Promise<string> {
    const buffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    return this.arrayBufferToHex(hashBuffer);
  }

  private async calculateBlobHash(blob: Blob): Promise<string> {
    const buffer = await blob.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    return this.arrayBufferToHex(hashBuffer);
  }

  private arrayBufferToHex(buffer: ArrayBuffer): string {
    return Array.from(new Uint8Array(buffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–å®ç°

### 1. WebWorkerå¹¶è¡Œå¤„ç†
```typescript
// worker.ts
self.onmessage = async (e) => {
  const { imageData, watermarkConfig } = e.data;
  
  // åœ¨Workerä¸­å¤„ç†å›¾ç‰‡
  const processedImage = await processImageInWorker(imageData, watermarkConfig);
  
  self.postMessage({ processedImage });
};

// ä¸»çº¿ç¨‹ä½¿ç”¨
class WorkerManager {
  private worker: Worker;

  constructor() {
    this.worker = new Worker('/watermark-worker.js');
  }

  async processImage(imageData: ImageData, config: any): Promise<Blob> {
    return new Promise((resolve) => {
      this.worker.postMessage({ imageData, config });
      this.worker.onmessage = (e) => {
        resolve(e.data.processedImage);
      };
    });
  }
}
```

### 2. åˆ†å—å¤„ç†å¤§æ–‡ä»¶
```typescript
class ChunkedProcessor {
  private chunkSize = 1024 * 1024; // 1MB chunks

  async processLargeImage(file: File): Promise<Blob> {
    const totalChunks = Math.ceil(file.size / this.chunkSize);
    const chunks: Blob[] = [];

    for (let i = 0; i < totalChunks; i++) {
      const start = i * this.chunkSize;
      const end = Math.min(start + this.chunkSize, file.size);
      const chunk = file.slice(start, end);
      
      // å¤„ç†æ¯ä¸ªåˆ†å—
      const processedChunk = await this.processChunk(chunk);
      chunks.push(processedChunk);
      
      // æ›´æ–°è¿›åº¦
      this.updateProgress(i + 1, totalChunks);
    }

    return new Blob(chunks, { type: 'image/jpeg' });
  }
}
```

## ğŸŒ æµè§ˆå™¨å…¼å®¹æ€§æ–¹æ¡ˆ

### ç‰¹æ€§æ£€æµ‹ä¸é™çº§
```typescript
class CompatibilityManager {
  static checkSupport(): CompatibilityReport {
    return {
      canvas: !!window.HTMLCanvasElement,
      webCrypto: !!window.crypto?.subtle,
      webWorkers: !!window.Worker,
      fileApi: !!window.FileReader,
      recommended: this.getRecommendedConfig()
    };
  }

  static getPolyfills(): string[] {
    const polyfills = [];
    
    if (!window.crypto?.subtle) {
      polyfills.push('webcrypto-shim');
    }
    
    if (!window.Worker) {
      polyfills.push('fake-worker');
    }
    
    return polyfills;
  }
}
```

### æ¸è¿›å¢å¼ºç­–ç•¥
```typescript
class ProgressiveEnhancement {
  private features = new Map();

  initialize() {
    // åŸºç¡€åŠŸèƒ½ï¼ˆæ‰€æœ‰æµè§ˆå™¨ï¼‰
    this.features.set('basic-watermark', true);
    
    // å¢å¼ºåŠŸèƒ½ï¼ˆç°ä»£æµè§ˆå™¨ï¼‰
    if (this.supportsWebWorkers()) {
      this.features.set('parallel-processing', true);
    }
    
    if (this.supportsWebCrypto()) {
      this.features.set('certificate-generation', true);
    }
    
    // æœ€ä¼˜åŠŸèƒ½ï¼ˆæœ€æ–°æµè§ˆå™¨ï¼‰
    if (this.supportsWebGL()) {
      this.features.set('advanced-effects', true);
    }
  }
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•æ¶æ„
```typescript
// æµ‹è¯•ç”¨ä¾‹ç¤ºä¾‹
describe('WatermarkRenderer', () => {
  let renderer: WatermarkRenderer;

  beforeEach(() => {
    renderer = new WatermarkRenderer();
  });

  test('æ–‡å­—æ°´å°æ­£ç¡®æ¸²æŸ“', async () => {
    const mockImage = createMockImage(800, 600);
    const textConfig = {
      content: 'æµ‹è¯•æ°´å°',
      fontSize: 24,
      color: '#000000',
      opacity: 0.5,
      position: 'bottom-right'
    };

    const result = await renderer.renderWatermark(mockImage, textConfig);
    expect(result).toBeInstanceOf(Blob);
    expect(result.type).toBe('image/jpeg');
  });

  test('æ€§èƒ½åŸºå‡†æµ‹è¯•', async () => {
    const mockImage = createMockImage(1920, 1080);
    const startTime = performance.now();
    
    await renderer.renderWatermark(mockImage, { content: 'æµ‹è¯•' });
    
    const endTime = performance.now();
    expect(endTime - startTime).toBeLessThan(3000);
  });
});
```

### E2Eæµ‹è¯•åœºæ™¯
```typescript
// Playwrightæµ‹è¯•
test('å®Œæ•´æ°´å°æµç¨‹', async ({ page }) => {
  await page.goto('/watermark-tool');
  
  // ä¸Šä¼ å›¾ç‰‡
  await page.setInputFiles('input[type="file"]', 'test-image.jpg');
  
  // é…ç½®æ–‡å­—æ°´å°
  await page.fill('[data-testid="text-content"]', 'ç‰ˆæƒæ‰€æœ‰');
  await page.selectOption('[data-testid="position"]', 'bottom-right');
  
  // å¤„ç†å›¾ç‰‡
  await page.click('[data-testid="process-btn"]');
  
  // éªŒè¯ç»“æœ
  await page.waitForSelector('[data-testid="result-image"]');
  const hasWatermark = await page.evaluate(() => {
    const canvas = document.querySelector('canvas');
    return canvas !== null;
  });
  
  expect(hasWatermark).toBe(true);
});
```

## ğŸ“¦ éƒ¨ç½²é…ç½®

### Viteæ„å»ºé…ç½®
```typescript
// vite.config.ts
export default defineConfig({
  build: {
    target: 'es2020',
    rollupOptions: {
      output: {
        manualChunks: {
          'watermark-core': ['./src/core/watermark-engine'],
          'ui-components': ['./src/components'],
          'utils': ['./src/utils']
        }
      }
    }
  },
  optimizeDeps: {
    include: ['react', 'react-dom']
  }
});
```

### æ€§èƒ½é¢„ç®—
```typescript
// bundle-size-limits.json
{
  "maxBundleSize": "500KB",
  "maxChunkSize": "200KB",
  "targets": {
    "watermark-core": "150KB",
    "ui-components": "100KB",
    "main-app": "200KB"
  }
}
```

## ğŸ” ç›‘æ§ä¸è°ƒè¯•

### æ€§èƒ½ç›‘æ§
```typescript
class PerformanceMonitor {
  static trackOperation(name: string, fn: () => Promise<any>) {
    const startTime = performance.now();
    const startMemory = performance.memory?.usedJSHeapSize || 0;
    
    try {
      const result = await fn();
      
      const endTime = performance.now();
      const endMemory = performance.memory?.usedJSHeapSize || 0;
      
      this.recordMetric({
        operation: name,
        duration: endTime - startTime,
        memoryDelta: endMemory - startMemory,
        timestamp: Date.now()
      });
      
      return result;
    } catch (error) {
      this.recordError(name, error);
      throw error;
    }
  }
}
```

è¿™å¥—æŠ€æœ¯æ–¹æ¡ˆç¡®ä¿äº†é«˜æ€§èƒ½ã€è·¨å…¼å®¹æ€§çš„æµè§ˆå™¨ç«¯æ°´å°å¤„ç†ç³»ç»Ÿï¼Œå®Œå…¨æ»¡è¶³MVPéœ€æ±‚ä¸”å…·å¤‡æ‰©å±•æ€§ã€‚