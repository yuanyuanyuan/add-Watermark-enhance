# 水印产品技术实现方案

## 🏗️ 技术架构概览

### 前端技术栈
- **框架**: React 18 + TypeScript 5.0
- **样式**: TailwindCSS + CSS Modules
- **状态管理**: Zustand (轻量级)
- **构建工具**: Vite 5.0
- **测试**: Jest + React Testing Library

### 核心技术方案

#### 1. Canvas渲染引擎架构
```typescript
interface WatermarkEngine {
  // 文字水印配置
  textWatermark: {
    content: string;
    fontSize: number;
    color: string;
    opacity: number;
    position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center';
    rotation: number;
  };
  
  // 图片水印配置
  imageWatermark: {
    src: string;
    scale: number;
    opacity: number;
    position: { x: number; y: number };
    rotation: number;
  };
}
```

#### 2. 性能优化策略
**分层渲染架构**:
- **L1**: 离屏Canvas预处理
- **L2**: WebWorker并行处理
- **L3**: 分块处理大文件
- **L4**: 渐进式加载

**内存管理**:
```typescript
class MemoryManager {
  private maxMemoryMB = 100;
  private activeCanvases = new Set<HTMLCanvasElement>();
  
  allocateCanvas(width: number, height: number): HTMLCanvasElement {
    const estimatedMemory = (width * height * 4) / (1024 * 1024);
    if (this.getUsedMemory() + estimatedMemory > this.maxMemoryMB) {
      this.cleanupOldestCanvas();
    }
    return this.createCanvas(width, height);
  }
}
```

## 🔧 核心模块实现

### 模块1: 文件处理系统
```typescript
// 文件读取与验证
class FileProcessor {
  private supportedFormats = ['image/jpeg', 'image/png'];
  private maxFileSize = 10 * 1024 * 1024; // 10MB

  async processFile(file: File): Promise<ProcessedImage> {
    // 1. 格式验证
    if (!this.supportedFormats.includes(file.type)) {
      throw new Error('不支持的文件格式');
    }
    
    // 2. 大小检查
    if (file.size > this.maxFileSize) {
      throw new Error('文件过大，最大支持10MB');
    }
    
    // 3. 图片预加载和元数据提取
    const image = await this.loadImage(file);
    return {
      originalFile: file,
      image,
      dimensions: { width: image.width, height: image.height },
      metadata: await this.extractMetadata(file)
    };
  }
}
```

### 模块2: 水印渲染引擎
```typescript
class WatermarkRenderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d')!;
  }

  async renderWatermark(
    image: HTMLImageElement,
    textConfig?: TextWatermarkConfig,
    imageConfig?: ImageWatermarkConfig
  ): Promise<Blob> {
    // 1. 设置Canvas尺寸
    this.canvas.width = image.width;
    this.canvas.height = image.height;
    
    // 2. 绘制原始图片
    this.ctx.drawImage(image, 0, 0);
    
    // 3. 应用文字水印
    if (textConfig) {
      await this.applyTextWatermark(textConfig);
    }
    
    // 4. 应用图片水印
    if (imageConfig) {
      await this.applyImageWatermark(imageConfig);
    }
    
    // 5. 导出处理后的图片
    return new Promise(resolve => {
      this.canvas.toBlob(resolve, 'image/jpeg', 0.92);
    });
  }

  private applyTextWatermark(config: TextWatermarkConfig) {
    this.ctx.save();
    
    // 设置文字样式
    this.ctx.font = `${config.fontSize}px Arial`;
    this.ctx.fillStyle = config.color;
    this.ctx.globalAlpha = config.opacity;
    
    // 计算文字位置
    const position = this.calculateTextPosition(config);
    
    // 应用旋转
    this.ctx.translate(position.x, position.y);
    this.ctx.rotate(config.rotation * Math.PI / 180);
    
    // 绘制文字
    this.ctx.fillText(config.content, 0, 0);
    
    this.ctx.restore();
  }
}
```

### 模块3: SHA-256证书系统
```typescript
class CertificateGenerator {
  private encoder = new TextEncoder();

  async generateCertificate(
    originalFile: File,
    watermarkParams: WatermarkParams,
    processedImage: Blob
  ): Promise<WatermarkCertificate> {
    
    // 1. 计算原始文件哈希
    const originalHash = await this.calculateFileHash(originalFile);
    
    // 2. 计算处理后图片哈希
    const processedHash = await this.calculateBlobHash(processedImage);
    
    // 3. 生成证书元数据
    const metadata = {
      originalHash,
      processedHash,
      watermarkParams,
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    };
    
    // 4. 计算证书哈希
    const certificateHash = await this.calculateStringHash(
      JSON.stringify(metadata)
    );
    
    return {
      ...metadata,
      certificateHash
    };
  }

  private async calculateFileHash(file: File): Promise<string> {
    const buffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    return this.arrayBufferToHex(hashBuffer);
  }

  private async calculateBlobHash(blob: Blob): Promise<string> {
    const buffer = await blob.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    return this.arrayBufferToHex(hashBuffer);
  }

  private arrayBufferToHex(buffer: ArrayBuffer): string {
    return Array.from(new Uint8Array(buffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
}
```

## ⚡ 性能优化实现

### 1. WebWorker并行处理
```typescript
// worker.ts
self.onmessage = async (e) => {
  const { imageData, watermarkConfig } = e.data;
  
  // 在Worker中处理图片
  const processedImage = await processImageInWorker(imageData, watermarkConfig);
  
  self.postMessage({ processedImage });
};

// 主线程使用
class WorkerManager {
  private worker: Worker;

  constructor() {
    this.worker = new Worker('/watermark-worker.js');
  }

  async processImage(imageData: ImageData, config: any): Promise<Blob> {
    return new Promise((resolve) => {
      this.worker.postMessage({ imageData, config });
      this.worker.onmessage = (e) => {
        resolve(e.data.processedImage);
      };
    });
  }
}
```

### 2. 分块处理大文件
```typescript
class ChunkedProcessor {
  private chunkSize = 1024 * 1024; // 1MB chunks

  async processLargeImage(file: File): Promise<Blob> {
    const totalChunks = Math.ceil(file.size / this.chunkSize);
    const chunks: Blob[] = [];

    for (let i = 0; i < totalChunks; i++) {
      const start = i * this.chunkSize;
      const end = Math.min(start + this.chunkSize, file.size);
      const chunk = file.slice(start, end);
      
      // 处理每个分块
      const processedChunk = await this.processChunk(chunk);
      chunks.push(processedChunk);
      
      // 更新进度
      this.updateProgress(i + 1, totalChunks);
    }

    return new Blob(chunks, { type: 'image/jpeg' });
  }
}
```

## 🌐 浏览器兼容性方案

### 特性检测与降级
```typescript
class CompatibilityManager {
  static checkSupport(): CompatibilityReport {
    return {
      canvas: !!window.HTMLCanvasElement,
      webCrypto: !!window.crypto?.subtle,
      webWorkers: !!window.Worker,
      fileApi: !!window.FileReader,
      recommended: this.getRecommendedConfig()
    };
  }

  static getPolyfills(): string[] {
    const polyfills = [];
    
    if (!window.crypto?.subtle) {
      polyfills.push('webcrypto-shim');
    }
    
    if (!window.Worker) {
      polyfills.push('fake-worker');
    }
    
    return polyfills;
  }
}
```

### 渐进增强策略
```typescript
class ProgressiveEnhancement {
  private features = new Map();

  initialize() {
    // 基础功能（所有浏览器）
    this.features.set('basic-watermark', true);
    
    // 增强功能（现代浏览器）
    if (this.supportsWebWorkers()) {
      this.features.set('parallel-processing', true);
    }
    
    if (this.supportsWebCrypto()) {
      this.features.set('certificate-generation', true);
    }
    
    // 最优功能（最新浏览器）
    if (this.supportsWebGL()) {
      this.features.set('advanced-effects', true);
    }
  }
}
```

## 🧪 测试策略

### 单元测试架构
```typescript
// 测试用例示例
describe('WatermarkRenderer', () => {
  let renderer: WatermarkRenderer;

  beforeEach(() => {
    renderer = new WatermarkRenderer();
  });

  test('文字水印正确渲染', async () => {
    const mockImage = createMockImage(800, 600);
    const textConfig = {
      content: '测试水印',
      fontSize: 24,
      color: '#000000',
      opacity: 0.5,
      position: 'bottom-right'
    };

    const result = await renderer.renderWatermark(mockImage, textConfig);
    expect(result).toBeInstanceOf(Blob);
    expect(result.type).toBe('image/jpeg');
  });

  test('性能基准测试', async () => {
    const mockImage = createMockImage(1920, 1080);
    const startTime = performance.now();
    
    await renderer.renderWatermark(mockImage, { content: '测试' });
    
    const endTime = performance.now();
    expect(endTime - startTime).toBeLessThan(3000);
  });
});
```

### E2E测试场景
```typescript
// Playwright测试
test('完整水印流程', async ({ page }) => {
  await page.goto('/watermark-tool');
  
  // 上传图片
  await page.setInputFiles('input[type="file"]', 'test-image.jpg');
  
  // 配置文字水印
  await page.fill('[data-testid="text-content"]', '版权所有');
  await page.selectOption('[data-testid="position"]', 'bottom-right');
  
  // 处理图片
  await page.click('[data-testid="process-btn"]');
  
  // 验证结果
  await page.waitForSelector('[data-testid="result-image"]');
  const hasWatermark = await page.evaluate(() => {
    const canvas = document.querySelector('canvas');
    return canvas !== null;
  });
  
  expect(hasWatermark).toBe(true);
});
```

## 📦 部署配置

### Vite构建配置
```typescript
// vite.config.ts
export default defineConfig({
  build: {
    target: 'es2020',
    rollupOptions: {
      output: {
        manualChunks: {
          'watermark-core': ['./src/core/watermark-engine'],
          'ui-components': ['./src/components'],
          'utils': ['./src/utils']
        }
      }
    }
  },
  optimizeDeps: {
    include: ['react', 'react-dom']
  }
});
```

### 性能预算
```typescript
// bundle-size-limits.json
{
  "maxBundleSize": "500KB",
  "maxChunkSize": "200KB",
  "targets": {
    "watermark-core": "150KB",
    "ui-components": "100KB",
    "main-app": "200KB"
  }
}
```

## 🔍 监控与调试

### 性能监控
```typescript
class PerformanceMonitor {
  static trackOperation(name: string, fn: () => Promise<any>) {
    const startTime = performance.now();
    const startMemory = performance.memory?.usedJSHeapSize || 0;
    
    try {
      const result = await fn();
      
      const endTime = performance.now();
      const endMemory = performance.memory?.usedJSHeapSize || 0;
      
      this.recordMetric({
        operation: name,
        duration: endTime - startTime,
        memoryDelta: endMemory - startMemory,
        timestamp: Date.now()
      });
      
      return result;
    } catch (error) {
      this.recordError(name, error);
      throw error;
    }
  }
}
```

这套技术方案确保了高性能、跨兼容性的浏览器端水印处理系统，完全满足MVP需求且具备扩展性。